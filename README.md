# GoBank: A Simple Bank Backend Service

This repository contains the source code for a simple bank backend service written in Go. It provides basic functionalities like creating accounts, managing entries, and performing transfers between accounts. The project is built with a focus on database transactions to ensure data consistency.

## 1. Project Overview

The core of this project is a robust database layer generated by `sqlc`, which provides type-safe Go code from raw SQL queries. The most important architectural pattern used here is the **Store pattern**, which allows for the composition of multiple database operations into a single, atomic transaction.

This README will walk you through the project structure, database schema, the `sqlc` setup, and a deep dive into why the `Store` pattern is crucial for applications like this.

## 2. Prerequisites & Setup

To run this project, you will need:
-   Go (version 1.15+)
-   Docker and Docker Compose
-   `sqlc` for code generation (`go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest`)
-   `migrate` for database migrations (`go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest`)

### Makefile

The `Makefile` provides several useful commands to manage the project:

```makefile
# From: Makefile

postgres:
	docker run --name postgres17 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -d postgres:17-alpine
createdb:
	docker exec -it postgres17 createdb --username=root --owner=root simple_bank
dropdb:
	docker exec -it postgres17 dropdb simple_bank
migrateup:
	migrate -path db/migration -database "postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose up
migratedown:
	migrate -path db/migration -database "postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose down
sqlc:
	sqlc generate
test:
	go test -v -cover ./...
```

-   `make postgres`: Starts a PostgreSQL container using Docker.
-   `make createdb`: Creates the `simple_bank` database.
-   `make migrateup`: Applies all database migrations.
-   `make sqlc`: Generates Go code from your SQL queries.
-   `make test`: Runs all tests.

### Database migrations (up vs down)

Use the Makefile targets to precisely control migration direction and version:

-   `make migrateup`: Apply all pending up migrations to the latest version
-   `make migrateup1`: Apply exactly one up migration (advance by 1)
-   `make migratedown`: Roll back all migrations (down to version 0)
-   `make migratedown1`: Roll back exactly one migration (go back by 1)
-   `make migrategoto v=NUM`: Move to a specific version number (example: `make migrategoto v=1`)
-   `make migrateversion`: Print the current migration version
-   `make migratenew name=feature_name`: Create a new timestamped migration pair in `db/migration`

Examples:

```bash
# Up all the way to latest
make migrateup

# Up or down by one step
make migrateup1
make migratedown1

# Show current version
make migrateversion
```

## 3. Database Schema

The database schema is defined in `db/migration/000001_init_schema.up.sql`. It consists of three main tables:

-   `accounts`: Stores account information, including owner, balance, and currency.
-   `entries`: Records all changes to account balances (can be positive or negative).
-   `transfers`: Logs the movement of money from one account to another.

```sql
-- From: db/migration/000001_init_schema.up.sql

CREATE TABLE "accounts" (
  "id" bigserial PRIMARY KEY,
  "owner" varchar NOT NULL,
  "balance" bigint NOT NULL,
  "currency" varchar NOT NULL,
  "created_at" timestamptz NOT NULL DEFAULT (now())
);

CREATE TABLE "entries" (
  "id" bigserial PRIMARY KEY,
  "account_id" bigint NOT NULL,
  "amount" bigint NOT NULL,
  "created_at" timestamptz NOT NULL DEFAULT (now())
);

CREATE TABLE "transfers" (
  "id" bigserial PRIMARY KEY,
  "from_account_id" bigint NOT NULL,
  "to_account_id" bigint NOT NULL,
  "amount" bigint NOT NULL,
  "created_at" timestamptz NOT NULL DEFAULT (now())
);
```

## 4. `sqlc` - Generating Type-Safe Go Code

`sqlc` is a command-line tool that generates Go code from SQL. It uses your SQL queries (`db/query/*.sql`) to create Go methods and structs.

### Configuration (`sqlc.yaml`)

```yaml
# From: sqlc.yaml

version: "2"
sql:
  - engine: "postgresql"
    schema: "./db/migration/"
    queries: "./db/query/"
    gen:
        go:
            out: "./db/sqlc"
            package: "db"
            sql_package: "database/sql"
            emit_json_tags: true
            emit_prepared_queries: false
            emit_interface: false
            emit_exact_table_names: false
```

### Queries

Here is an example of a query from `db/query/account.sql`:

```sql
-- From: db/query/account.sql

-- name: CreateAccount :one
INSERT INTO accounts(
    owner, 
    balance, 
    currency
) VALUES (
    $1, $2, $3
) RETURNING *;
```

`sqlc` will generate a `CreateAccount` method in Go that takes the specified parameters and returns the newly created `Account` struct.

## 5. The Store Pattern: A Deep Dive into Transactions

Alright — here’s the **Hormozi-style README** that’s all about **where `Queries` falls short** and why the `Store` pattern fixes it.

---

#  The Store Pattern in Go — Fixing `Queries`' Biggest Weakness

---

## **1. Where `Queries` Falls Short**

The `Queries` struct from SQLC is amazing for single queries:

```go
q.CreateAccount(...)
q.GetAccount(...)
```

But here’s the catch:
**Each call runs its own transaction under the hood.**

If you call them one after another — they are **NOT** tied together.
It’s like swiping your credit card for every single item at the store.
If one fails, you can’t “undo” the others.

---

## **2. Step 1 — `Queries` Uses `*sql.DB` by Default**

When SQLC generates code, you get something like:

```go
// From: db/sqlc/db.go

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type Queries struct {
    db DBTX // DBTX can be *sql.DB or *sql.Tx
}
```

If you do:

```go
q := New(db) // db is *sql.DB
q.CreateAccount(...)
```

Each query:

* Opens a new transaction internally
* Executes
* Closes immediately

No connection between queries.

---

## **3. Step 2 — A Transaction is `*sql.Tx`**

When you start a transaction in Go:

```go
tx, err := db.BeginTx(ctx, nil)
```

You get `*sql.Tx` — **not** the same as `*sql.DB`.

The difference:

* **`*sql.DB`** → Every query is its own little world
* **`*sql.Tx`** → All queries share the same world until you `Commit` or `Rollback`

---

## **4. Step 3 — Give `Queries` the Transaction**

Instead of:

```go
q := New(db)
```

We do:

```go
q := New(tx) // tx is *sql.Tx
```

Now:

* Every query through `q` is using the **same transaction**
* Nothing is final until you say so

---

## **5. Step 4 — All Queries in One “Bucket”**

Inside `Store.execTx`, we do exactly that:

```go
// From: db/sqlc/store.go

func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
    tx, err := store.db.BeginTx(ctx, nil) // open transaction
    if err != nil { return err }

    q := New(tx) // same transaction for all queries
    err = fn(q)

    if err != nil {
        tx.Rollback() // undo everything
        return err
    }
    return tx.Commit() // save everything
}
```

---

## **6. Step 5 — Why This Works**

`*sql.Tx` remembers all changes until you `Commit` or `Rollback`.

It’s like:

* Opening a **tab** at a restaurant
* Ordering drinks, food, dessert — all added to the same bill
* At the end:

  * **Commit** → Pay the bill
  * **Rollback** → Tear it up, no charge

Without this pattern:

* You’re paying for each dish separately
* If dessert never arrives, you’ve already paid for drinks and food

---

## **7. Why Use `Store` Instead of Doing This Manually**

Yes, you could start transactions yourself every time —
but that leads to:

* Repeated boilerplate
* Scattered transaction handling
* Harder testing
* More places for bugs

`Store` centralizes:

* How you open transactions
* How you commit or rollback
* How queries share one transaction

Your `store.go` file demonstrates this perfectly:

```go
// From: db/sqlc/store.go

// Store provides all functions to execute db queries and transactions
type Store struct {
	*Queries
	db *sql.DB
}

func NewStore(db *sql.DB) *Store {
	return &Store{
		db:      db,
		Queries: New(db),
	}
}

// TransferTx performs a money transfer from one account to another
func (s *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {
	var result TransferTxResult

	err := s.execTx(ctx, func(q *Queries) error {
		var err error
		result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams{
			FromAccountID: arg.FromAccountID,
			ToAccountID:   arg.ToAccountID,
			Amount:        arg.Amount,
		})
		if err != nil {
			return err
		}

		// ... other operations ...

		return nil
	})
	return result, err
}
```

---

## **8. TL;DR**

* `Queries` is great for single DB operations — bad for multi-step processes
* `*sql.DB` → each query is its own transaction
* `*sql.Tx` → multiple queries share one transaction
* `Store` makes it easy to run multi-step business logic safely and cleanly

---

## **9. Critical Concurrency Concept: Race Conditions & FOR UPDATE**

### **The Problem: Race Conditions in Account Updates**

When multiple transactions try to update the same account simultaneously, you can encounter **race conditions** that lead to incorrect results. Here's what happens:

```go
// Transaction 1: Transfer $100 from Account A to Account B
// Transaction 2: Transfer $50 from Account A to Account C

// Both transactions read Account A balance at the same time
// Both see balance = $1000
// Transaction 1: 1000 - 100 = $900
// Transaction 2: 1000 - 50 = $950
// Final balance becomes $950 (incorrect! Should be $850)
```

### **The Solution: FOR UPDATE Locking**

To prevent race conditions, we use `SELECT ... FOR UPDATE` which creates a **row-level lock**:

```sql
-- From: db/query/account.sql

-- name: GetAccountsForUpdate :one
SELECT * FROM accounts
WHERE id = $1 LIMIT 1
FOR UPDATE;
```

**What `FOR UPDATE` does:**
- **Blocks** other transactions from reading/modifying the same row
- Forces transactions to wait until the lock is released
- Ensures **serializable** access to critical data

### **Implementation in TransferTx**

```go
// From: db/sqlc/store.go

func (s *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {
	var result TransferTxResult

	err := s.execTx(ctx, func(q *Queries) error {
		// ... create transfer and entries ...

		// LOCK the from account - other transactions must wait
		acc1, err := q.GetAccountsForUpdate(ctx, arg.FromAccountID)
		if err != nil {
			return fmt.Errorf("failed to get from account: %w", err)
		}

		// Update balance while holding the lock
		result.FromAccount, err = q.UpdateAccount(ctx, UpdateAccountParams{
			ID:      acc1.ID,
			Balance: acc1.Balance - arg.Amount,
		})

		// LOCK the to account - other transactions must wait
		acc2, err := q.GetAccountsForUpdate(ctx, arg.ToAccountID)
		if err != nil {
			return fmt.Errorf("failed to get to account: %w", err)
		}

		// Update balance while holding the lock
		result.ToAccount, err = q.UpdateAccount(ctx, UpdateAccountParams{
			ID:      acc2.ID,
			Balance: acc2.Balance + arg.Amount,
		})

		return nil
	})
	return result, err
}
```

### **The Deadlock Problem & Solution**

**Deadlock Scenario:**
```
Transaction 1: Locks Account A, then tries to lock Account B
Transaction 2: Locks Account B, then tries to lock Account A
→ Both wait forever for each other = DEADLOCK
```

#### **Real-World Deadlock Example from Your Test**

Here's exactly what happened in your test output:

```
tx-3  Create Transfer          ← Completes successfully (no interference)
tx-3  Creating entry 1
tx-3  Creating entry 2
tx-3  get account 1
tx-3 update account 1 balance
tx-3  get account 2
tx-3 update account 2 balance

tx-2  Create Transfer         ← Starts running
tx-1  Create Transfer         ← Starts running concurrently

tx-1  Creating entry 1
tx-2  Creating entry 1
tx-1  Creating entry 2
tx-2  Creating entry 2

tx-1  get account 1           ← Both reach this step simultaneously
tx-2  get account 1

tx-2 update account 1 balance ← tx-2 gets the lock first and updates
tx-1  get account 1           ← tx-1 tries to get lock but DEADLOCK!
```

#### **Why the Deadlock Happens**

**Transaction tx-1** (account1 → account2):
- ✅ Gets lock on account1 first
- ⏳ Tries to get lock on account2 (waiting for tx-2 to release it)

**Transaction tx-2** (account2 → account1):
- ✅ Gets lock on account2 first  
- ⏳ Tries to get lock on account1 (waiting for tx-1 to release it)

**Result**: Both transactions are waiting for each other → **DEADLOCK DETECTED**

#### **The Root Cause**

Your current code locks accounts in **random order**:
```go
// Current problematic code:
acc1, err := q.GetAccountsForUpdate(ctx, arg.FromAccountID)  // Lock account1
acc2, err := q.GetAccountsForUpdate(ctx, arg.ToAccountID)    // Lock account2
```

When multiple transactions run concurrently:
- **tx-1** might lock account1 first, then try account2
- **tx-2** might lock account2 first, then try account1
- **Result**: Circular wait = Deadlock

### **Why INSERT Creates Locks (The Hidden Culprit)**

Here's the **real reason** why you're getting deadlocks - it's not just your `SELECT ... FOR UPDATE` queries!

#### **Foreign Key Constraint Locking**

When you do this:
```sql
INSERT INTO transfers (from_account_id, to_account_id, amount) VALUES (1, 2, 100);
```

PostgreSQL has to check the foreign key constraint:
```sql
-- Your table has this constraint:
ALTER TABLE "transfers" ADD FOREIGN KEY ("from_account_id") REFERENCES "accounts" ("id");
ALTER TABLE "transfers" ADD FOREIGN KEY ("to_account_id") REFERENCES "accounts" ("id");
```

#### **What PostgreSQL Does Behind the Scenes**

Before allowing the INSERT, it **MUST** verify:
- "Does account ID 1 actually exist?"
- "Does account ID 2 actually exist?"

To check this, PostgreSQL secretly runs:
```sql
SELECT * FROM accounts WHERE id = 1;  -- ← Creates SHARED LOCK
SELECT * FROM accounts WHERE id = 2;  -- ← Creates SHARED LOCK
```

#### **Why It Needs to Lock**

What if this happened **without locks**?
```
Time 1: INSERT checks "does account 1 exist?" → YES ✓
Time 2: Someone DELETES account 1 
Time 3: INSERT completes → Now you have invalid data! 💥
```

The lock prevents this:
- **INSERT says**: "I'm checking account 1 exists, nobody delete it until I'm done!"
- **The lock ensures** account 1 can't be deleted while the INSERT is happening

#### **The Real Issue**

The INSERT holds these "checking locks" **until the entire transaction finishes**, not just until the INSERT finishes.

That's why you see the conflict - the INSERT is still holding its "I'm checking this account exists" lock when your `SELECT ... FOR UPDATE` tries to modify the same account.

#### **Lock Sequence That Causes Deadlock**

```
Transaction 1:
1. INSERT transfer (locks accounts 1 & 2 with SHARED locks)
2. SELECT ... FOR UPDATE account 1 (waits for SHARED lock to be released)

Transaction 2:
1. INSERT transfer (locks accounts 2 & 1 with SHARED locks)  
2. SELECT ... FOR UPDATE account 2 (waits for SHARED lock to be released)

Result: Both waiting for each other = DEADLOCK!
```

#### **Solution: Consistent Lock Ordering**

Always lock accounts in the **same order** (e.g., by ID):

```go
// Get accounts in consistent order to prevent deadlocks
if arg.FromAccountID < arg.ToAccountID {
    acc1, err := q.GetAccountsForUpdate(ctx, arg.FromAccountID)
    acc2, err := q.GetAccountsForUpdate(ctx, arg.ToAccountID)
} else {
    acc2, err := q.GetAccountsForUpdate(ctx, arg.ToAccountID)
    acc1, err := q.GetAccountsForUpdate(ctx, arg.FromAccountID)
}
```

**Why This Works:**
- **All transactions** will always lock accounts in the **same order**
- **No circular wait** possible
- **Deadlock prevention** guaranteed

#### **Alternative Solution: FOR NO KEY UPDATE vs FOR UPDATE**

You might wonder: "What if I use `FOR NO KEY UPDATE` instead of `FOR UPDATE`? Will that prevent deadlocks?"

##### **The Difference Between Lock Modes**

```sql
-- Current approach (stronger lock):
SELECT * FROM accounts WHERE id = $1 FOR UPDATE;

-- Alternative approach (weaker lock):
SELECT * FROM accounts WHERE id = $1 FOR NO KEY UPDATE;
```

##### **What Each Lock Mode Does**

**`FOR UPDATE`:**
- **Locks the entire row** (including all columns)
- **Prevents any modifications** to the row
- **Strongest row-level lock**
- **Blocks other FOR UPDATE queries**

**`FOR NO KEY UPDATE`:**
- **Locks the row but allows key updates**
- **Prevents modifications to non-key columns**
- **Weaker lock than FOR UPDATE**
- **Still blocks other FOR NO KEY UPDATE queries**

##### **Why FOR NO KEY UPDATE Might Help**

`FOR NO KEY UPDATE` can reduce deadlock probability because:

1. **Less aggressive locking** - doesn't block as many operations
2. **Allows concurrent key updates** - other transactions can modify the same row
3. **Reduced lock contention** - fewer conflicts between transactions

##### **But It's NOT a Complete Solution**

**Problems with FOR NO KEY UPDATE:**

1. **Still creates locks** - you can still get deadlocks
2. **Weaker protection** - doesn't prevent all race conditions
3. **Key updates allowed** - other transactions could modify the ID (though unlikely in your case)
4. **Same ordering requirement** - you still need consistent lock ordering

##### **When to Use Each**

**Use `FOR UPDATE` when:**
- You need **maximum protection** against race conditions
- You're updating **critical data** (like account balances)
- You want to **prevent any concurrent modifications**

**Use `FOR NO KEY UPDATE` when:**
- You're updating **non-critical columns**
- You want to **reduce lock contention**
- You're okay with **weaker consistency guarantees**

##### **The Bottom Line**

While `FOR NO KEY UPDATE` might reduce deadlock frequency, it **doesn't eliminate the need for consistent lock ordering**. The fundamental solution remains:

1. **Consistent lock ordering** (by account ID)
2. **Proper transaction design**
3. **Understanding lock modes**

In your case, since you're updating **account balances** (critical financial data), `FOR UPDATE` is probably the right choice, combined with consistent lock ordering.

### **Why This Matters**

Without `FOR UPDATE`:
- ✅ **Fast** transactions
- ❌ **Incorrect** results due to race conditions
- ❌ **Data inconsistency**

With `FOR UPDATE`:
- ✅ **Correct** results guaranteed
- ✅ **Data consistency** maintained
- ⚠️ **Slower** due to waiting for locks
- ⚠️ **Potential deadlocks** if not handled properly

### **Testing the Race Condition**

The test failure you encountered demonstrates this:

```
fromAccount balance: 213
toAccount balance: 816
fromAccount balance: 203  ← Expected: 20, Got: 30
toAccount balance: 826
```

This happens because multiple test goroutines are updating the same accounts simultaneously without proper locking.

---

### **One-Way vs Reverse Transfers: Blocking vs Deadlock**

In our case, we usually transfer from account 1 → account 2. If we introduce a concurrent reverse flow (account 2 → account 1), two different behaviors can occur:

#### **Case A — Blocking (not a deadlock)**
- Routine 1: locks account 1, updates balance, returns
- Routine 2: locks account 2, updates balance, returns
- Now Routine 1 tries to update account 2 → it is **blocked**, because Routine 2 is still holding a lock on account 2 and hasn't committed yet
- Result: Routine 1 waits until Routine 2 commits/rolls back, then proceeds

This is normal lock waiting (blocking). It can appear "indefinite" if the other transaction is long-running, but it is not a deadlock.

#### **Case B — Deadlock (circular wait)**
- Routine 1: locks account 1, then needs account 2
- Routine 2: locks account 2, then needs account 1
- Both are now waiting for each other to release the lock
- Result: PostgreSQL detects the deadlock and aborts one transaction with `deadlock detected`

#### **Avoiding Both Problems**
- Always acquire locks in a **consistent order** (e.g., by account ID) before updating
- Keep transactions **short** (commit as soon as possible)
- For a given account pair, consider **serializing** transfers, or using an application-level mutex/shard
- Continue using `SELECT ... FOR UPDATE` (or `FOR NO KEY UPDATE` if appropriate) with consistent ordering

---

### **Bidirectional Updates: Why Deadlocks Happen and the Fix**

When two routines transfer in opposite directions (1 → 2 and 2 → 1) at the same time, each can lock a different account first, then try to lock the other. That creates a circular wait(deadlock):

- Routine A: locks account 1, then waits for account 2
- Routine B: locks account 2, then waits for account 1
- Neither can proceed → PostgreSQL detects a deadlock and aborts one

### **The Best Fix: Consistent Lock Ordering**

Make sure all transactions acquire locks in the same order, regardless of transfer direction. The simplest rule: always update the account with the smaller ID first, then the larger ID.

- If every transaction follows the same order, there is no circular wait
- A later transaction simply waits for the earlier one to release the first lock
- Once the first lock is released, it can proceed to acquire the same lock, then the second

### **Our Code Change (Smaller ID First)**

In `store.go`, we update balances in ID order, while preserving business logic (debit the sender, credit the receiver):

```go
// From: db/sqlc/store.go — update smaller ID first to avoid deadlocks
if arg.FromAccountID < arg.ToAccountID {
    // lock/update the smaller ID row first
    result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
        ID:     arg.FromAccountID,
        Amount: -arg.Amount, // debit sender
    })
    if err != nil {
        return fmt.Errorf("failed to update from account: %w", err)
    }
    result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
        ID:     arg.ToAccountID,
        Amount: +arg.Amount, // credit receiver
    })
    if err != nil {
        return fmt.Errorf("failed to update to account: %w", err)
    }
} else {
    // lock/update the smaller ID row first (which is ToAccount in this branch)
    result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
        ID:     arg.ToAccountID,
        Amount: +arg.Amount, // credit receiver
    })
    if err != nil {
        return fmt.Errorf("failed to update to account: %w", err)
    }
    result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
        ID:     arg.FromAccountID,
        Amount: -arg.Amount, // debit sender
    })
    if err != nil {
        return fmt.Errorf("failed to update from account: %w", err)
    }
}
```

This ensures every transaction touches rows in ascending ID order, eliminating circular waits. In your test with 10 concurrent transfers, all transactions now line up on the same first lock (the smaller ID). If one transaction is holding it, others wait for that same lock instead of grabbing the other account and causing a deadlock.

---

## **10. Debugging Deadlocks & Lock Issues**

When you encounter deadlocks or want to understand what's happening with database locks, PostgreSQL provides powerful monitoring queries. Here are the essential queries for debugging:

### **Query 1: Find Blocked vs Blocking Processes**

This query shows which processes are blocked and what's blocking them:

```sql
SELECT blocked_locks.pid     AS blocked_pid,
       blocked_activity.usename  AS blocked_user,
       blocking_locks.pid     AS blocking_pid,
       blocking_activity.usename AS blocking_user,
       blocked_activity.query    AS blocked_statement,
       blocking_activity.query   AS current_statement_in_blocking_process
FROM  pg_catalog.pg_locks         blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity  ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks         blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

**What This Shows:**
- **blocked_pid**: Process ID that's waiting for a lock
- **blocking_pid**: Process ID that's holding the lock
- **blocked_statement**: The query that's waiting
- **current_statement_in_blocking_process**: The query that's holding the lock

### **Query 2: List All Active Locks**

This query shows all current locks in the database:

```sql
SELECT a.datname,
       l.relation::regclass,
       l.transactionid,
       l.mode,
       l.GRANTED,
       a.usename,
       a.query,
       a.query_start,
       age(now(), a.query_start) AS "age",
       a.pid
FROM pg_stat_activity a
JOIN pg_locks l ON l.pid = a.pid
ORDER BY a.query_start;
```

**What This Shows:**
- **datname**: Database name
- **relation**: Table name being locked
- **mode**: Lock mode (e.g., `RowShareLock`, `ExclusiveLock`)
- **GRANTED**: Whether the lock is granted or waiting
- **query**: The actual SQL query
- **age**: How long the query has been running

### **How to Use These Queries**

1. **When You Get a Deadlock Error:**
   ```bash
   # Run Query 1 to see what's blocking what
   psql -d simple_bank -c "SELECT blocked_locks.pid AS blocked_pid..."
   ```

2. **To Monitor Lock Activity:**
   ```bash
   # Run Query 2 to see all current locks
   psql -d simple_bank -c "SELECT a.datname, l.relation::regclass..."
   ```

3. **In Your Go Tests:**
   ```go
   // Add this to your test to see locks during execution
   func debugLocks(t *testing.T, db *sql.DB) {
       rows, err := db.Query(`
           SELECT a.datname, l.relation::regclass, l.mode, l.GRANTED, a.usename, a.query
           FROM pg_stat_activity a
           JOIN pg_locks l ON l.pid = a.pid
           ORDER BY a.query_start;
       `)
       // ... process results
   }
   ```

### **Common Lock Modes You'll See**

- **`RowShareLock`**: SELECT ... FOR UPDATE (what you're using)
- **`ExclusiveLock`**: UPDATE/DELETE operations
- **`AccessShareLock`**: Regular SELECT queries

### **Debugging Your Deadlock**

When you run your test and get a deadlock:

1. **Run Query 1** to see which transactions are blocking each other
2. **Look for circular dependencies** (A waiting for B, B waiting for A)
3. **Check the queries** to understand what each transaction is trying to do
4. **Verify lock ordering** - ensure you're locking accounts in consistent order

This debugging approach will help you identify exactly where and why deadlocks occur in your concurrent database operations.

---

## 11. Gin Framework: HTTP Server & API Development

### What is Gin?
Gin is a high-performance HTTP web framework for Go. It features a martini-like API with performance that's up to 40x faster than other frameworks.

### Basic Setup & Usage
```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    r := gin.Default() // includes Logger & Recovery middleware
    
    // Routes
    r.GET("/ping", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"message": "pong"})
    })
    
    r.Run(":8080") // listen and serve on 0.0.0.0:8080
}
```

### HTTP Methods & Routing
```go
r := gin.Default()

// Basic routes
r.GET("/users", getUsers)
r.POST("/users", createUser)
r.PUT("/users/:id", updateUser)
r.DELETE("/users/:id", deleteUser)

// Route groups
v1 := r.Group("/api/v1")
{
    v1.GET("/accounts", getAccounts)
    v1.POST("/accounts", createAccount)
}
```

### URL Parameters vs URI Parameters vs Query Parameters

#### **1. URI Parameters (Path Parameters)**
Extracted from the URL path using `:param` syntax.

```go
// Route: GET /accounts/:id
type GetAccountRequest struct {
    ID int64 `uri:"id" binding:"required,min=1"`
}

func (server *Server) getAccount(ctx *gin.Context) {
    var req GetAccountRequest
    if err := ctx.ShouldBindUri(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, errorResponse(err))
        return
    }
    
    id := req.ID // extracted from /accounts/123 -> id = 123
    account, err := server.store.GetAccount(ctx, id)
    // ... handle response
}

// Route registration
server.router.GET("/accounts/:id", server.getAccount)
```

#### **2. Query Parameters**
Extracted from URL query string using `?key=value&key2=value2`.

```go
// Route: GET /accounts?page_id=1&page_size=5
type ListAccountsRequest struct {
    PageID   int32 `form:"page_id" binding:"required,min=1"`
    PageSize int32 `form:"page_size" binding:"required,min=5,max=10"`
}

func (server *Server) ListAccounts(ctx *gin.Context) {
    var req ListAccountsRequest
    if err := ctx.ShouldBindQuery(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, errorResponse(err))
        return
    }
    
    // Pagination logic
    arg := db.ListAccountsParams{
        Limit:  req.PageSize,
        Offset: (req.PageID - 1) * req.PageSize, // Convert page to offset
    }
    
    accounts, err := server.store.ListAccounts(ctx, arg)
    // ... handle response
}

// Route registration
server.router.GET("/accounts", server.ListAccounts)
```

#### **3. Request Body Parameters**
Extracted from JSON request body.

```go
// Route: POST /accounts
type CreateAccountRequest struct {
    Owner    string `json:"owner" binding:"required"`
    Currency string `json:"currency" binding:"required,oneof=USD EUR"`
}

func (server *Server) createAccount(ctx *gin.Context) {
    var req CreateAccountRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, errorResponse(err))
        return
    }
    
    arg := db.CreateAccountParams{
        Owner:    req.Owner,
        Currency: req.Currency,
    }
    
    account, err := server.store.CreateAccount(ctx, arg)
    // ... handle response
}

// Route registration
server.router.POST("/accounts", server.createAccount)
```

### Complete Route Setup Example

```go
func (server *Server) setupRouter() {
    // Account routes
    accounts := server.router.Group("/accounts")
    {
        accounts.POST("/", server.createAccount)           // POST /accounts
        accounts.GET("/:id", server.getAccount)           // GET /accounts/123
        accounts.GET("/", server.ListAccounts)            // GET /accounts?page_id=1&page_size=5
        accounts.PUT("/:id", server.updateAccount)        // PUT /accounts/123
        accounts.DELETE("/:id", server.deleteAccount)     // DELETE /accounts/123
    }
    
    // Transfer routes
    transfers := server.router.Group("/transfers")
    {
        transfers.POST("/", server.createTransfer)        // POST /transfers
        transfers.GET("/:id", server.getTransfer)        // GET /transfers/456
        transfers.GET("/", server.listTransfers)         // GET /transfers?page_id=1&page_size=10
    }
}
```

### Pagination Implementation

#### **Request Structure**
```go
type PaginationRequest struct {
    PageID   int32 `form:"page_id" binding:"required,min=1"`
    PageSize int32 `form:"page_size" binding:"required,min=1,max=100"`
}

// Convert to database offset
func (req *PaginationRequest) GetOffset() int32 {
    return (req.PageID - 1) * req.PageSize
}
```

#### **Database Query**
```go
// In your SQL query
-- name: ListAccounts :many
SELECT * FROM accounts
ORDER BY id
LIMIT $1 OFFSET $2;

// In Go code
arg := db.ListAccountsParams{
    Limit:  req.PageSize,        // e.g., 10
    Offset: req.GetOffset(),     // e.g., (2-1) * 10 = 10
}
```

#### **Response with Pagination Metadata**
```go
type PaginatedResponse struct {
    Data       interface{} `json:"data"`
    PageID     int32       `json:"page_id"`
    PageSize   int32       `json:"page_size"`
    TotalCount int64       `json:"total_count"`
    TotalPages int32       `json:"total_pages"`
}

func (server *Server) ListAccounts(ctx *gin.Context) {
    var req ListAccountsRequest
    if err := ctx.ShouldBindQuery(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, errorResponse(err))
        return
    }
    
    // Get total count for pagination metadata
    totalCount, err := server.store.GetAccountsCount(ctx)
    if err != nil {
        ctx.JSON(http.StatusInternalServerError, errorResponse(err))
        return
    }
    
    // Get paginated results
    arg := db.ListAccountsParams{
        Limit:  req.PageSize,
        Offset: req.GetOffset(),
    }
    
    accounts, err := server.store.ListAccounts(ctx, arg)
    if err != nil {
        ctx.JSON(http.StatusInternalServerError, errorResponse(err))
        return
    }
    
    // Calculate total pages
    totalPages := int32(math.Ceil(float64(totalCount) / float64(req.PageSize)))
    
    response := PaginatedResponse{
        Data:       accounts,
        PageID:     req.PageID,
        PageSize:   req.PageSize,
        TotalCount: totalCount,
        TotalPages: totalPages,
    }
    
    ctx.JSON(http.StatusOK, response)
}
```

### Parameter Binding Methods

| Method | Purpose | Example |
|--------|---------|---------|
| `ShouldBindJSON()` | Request body (JSON) | `POST /accounts` with JSON body |
| `ShouldBindUri()` | Path parameters | `GET /accounts/:id` |
| `ShouldBindQuery()` | Query parameters | `GET /accounts?page_id=1&page_size=5` |
| `ShouldBindForm()` | Form data | `POST /accounts` with form data |
| `ShouldBind()` | Auto-detect | Automatically chooses binding method |

### Validation Tags

```go
type AccountRequest struct {
    ID       int64  `uri:"id" binding:"required,min=1"`
    Name     string `json:"name" binding:"required,min=2,max=50"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"gte=0,lte=130"`
    Currency string `json:"currency" binding:"required,oneof=USD EUR CAD"`
    Amount   int64  `json:"amount" binding:"required,gt=0"`
}
```

**Common Validation Rules:**
- `required` - Field must be present
- `min=X` - Minimum value/length
- `max=X` - Maximum value/length
- `gt=X` - Greater than X
- `gte=X` - Greater than or equal to X
- `lt=X` - Less than X
- `lte=X` - Less than or equal to X
- `oneof=X Y Z` - Must be one of the specified values
- `email` - Must be valid email format

### Error Handling Patterns

```go
func errorResponse(err error) gin.H {
    return gin.H{"error": err.Error()}
}

func (server *Server) handleError(ctx *gin.Context, err error, statusCode int) {
    ctx.JSON(statusCode, errorResponse(err))
}

// Usage in handlers
func (server *Server) someHandler(ctx *gin.Context) {
    if err := doSomething(); err != nil {
        server.handleError(ctx, err, http.StatusInternalServerError)
        return
    }
    
    ctx.JSON(http.StatusOK, gin.H{"status": "success"})
}
```

### Middleware Examples

#### **Authentication Middleware**
```go
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "no token"})
            return
        }
        
        // Validate token...
        if !isValidToken(token) {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
            return
        }
        
        c.Next() // continue to next handler
    }
}
```

#### **Logging Middleware**
```go
func LoggingMiddleware() gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
            param.ClientIP,
            param.TimeStamp.Format(time.RFC1123),
            param.Method,
            param.Path,
            param.Request.Proto,
            param.StatusCode,
            param.Latency,
            param.Request.UserAgent(),
            param.ErrorMessage,
        )
    })
}
```

### Testing Your API Endpoints

```bash
# Create account
curl -X POST http://localhost:8080/accounts \
  -H "Content-Type: application/json" \
  -d '{"owner":"John Doe","currency":"USD"}'

# Get account by ID
curl http://localhost:8080/accounts/1

# List accounts with pagination
curl "http://localhost:8080/accounts?page_id=1&page_size=5"

# Update account
curl -X PUT http://localhost:8080/accounts/1 \
  -H "Content-Type: application/json" \
  -d '{"owner":"Jane Doe","currency":"EUR"}'

# Delete account
curl -X DELETE http://localhost:8080/accounts/1
```

### Best Practices

1. **Use route groups** for organizing related endpoints
2. **Validate all inputs** using binding tags
3. **Handle errors consistently** with structured responses
4. **Use appropriate HTTP status codes** (200, 201, 400, 401, 404, 500)
5. **Implement pagination** for list endpoints
6. **Add middleware** for cross-cutting concerns (auth, logging, CORS)
7. **Use descriptive route names** that follow REST conventions
8. **Test all endpoints** with different parameter combinations

## 12. Testing and Mocks (GoMock + httptest)

Use GoMock to unit test handlers and business logic without a real database. Use `httptest` to exercise HTTP endpoints.

### Install tooling
- GoMock libs (for assertions and gomock):
```bash
go install go.uber.org/mock/mockgen@latest
```

### Generate the store mock
Your store interface lives in `db/sqlc/store.go` as `type Store interface { ... }`. Generate a mock that implements it:
```bash
mockgen -package=mockdb -destination=db/mock/store.go github.com/ShubhKanodia/GoBank/db/sqlc Store
```
Note: This matches the header already present in `db/mock/store.go`.

### Run tests
- All tests:
```bash
make test
```
- Single test (example):
```bash
make test-one t=TestGetAccountAPI
```
- Full DB setup + tests (if needed):
```bash
make runtest
```

#### Note on incomplete test files
If there is any incomplete or empty `*_test.go` file (for example, missing a `package` declaration), `go test` will fail during package setup with errors like: `expected 'package', found 'EOF'`. Remove or fix such files before running tests.

### Pattern: API handler tests with mocks
Structure tests to be table-driven, with a `buildStubs` func to declare mock expectations and a `checkResponse` func to assert responses.
```go
func TestGetAccountAPI(t *testing.T) {
  account := randomAccount()

  testCases := []struct {
    name          string
    accountID     int64
    buildStubs    func(store *mockdb.MockStore)
    checkResponse func(rec *httptest.ResponseRecorder)
  }{
    {
      name: "OK",
      accountID: account.ID,
      buildStubs: func(store *mockdb.MockStore) {
        store.EXPECT().GetAccount(gomock.Any(), gomock.Eq(account.ID)).Times(1).Return(account, nil)
      },
      checkResponse: func(rec *httptest.ResponseRecorder) {
        require.Equal(t, http.StatusOK, rec.Code)
      },
    },
    {
      name: "NotFound",
      accountID: account.ID,
      buildStubs: func(store *mockdb.MockStore) {
        store.EXPECT().GetAccount(gomock.Any(), gomock.Eq(account.ID)).Times(1).Return(db.Account{}, sql.ErrNoRows)
      },
      checkResponse: func(rec *httptest.ResponseRecorder) {
        require.Equal(t, http.StatusNotFound, rec.Code)
      },
    },
  }

  for _, tc := range testCases {
    t.Run(tc.name, func(t *testing.T) {
      ctrl := gomock.NewController(t)
      defer ctrl.Finish()

      store := mockdb.NewMockStore(ctrl)
      tc.buildStubs(store)

      server := api.NewServer(store)
      rec := httptest.NewRecorder()
      req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("/accounts/%d", tc.accountID), nil)
      server.Router().ServeHTTP(rec, req)
      tc.checkResponse(rec)
    })
  }
}
```
Handler tip: map `sql.ErrNoRows` to 404 so tests can assert Not Found cleanly.
```go
acct, err := server.store.GetAccount(ctx.Request.Context(), id)
if err == sql.ErrNoRows { ctx.JSON(http.StatusNotFound, errorResponse(err)); return }
if err != nil { ctx.JSON(http.StatusInternalServerError, errorResponse(err)); return }
```

### Pattern: Concurrency tests without deadlocks or flakes
- Use buffered channels so goroutines don’t block when sending:
```go
n := 10
errs := make(chan error, n)
results := make(chan TransferTxResult, n)
for i := 0; i < n; i++ {
  go func() {
    res, err := store.TransferTx(context.Background(), args)
    errs <- err
    results <- res
  }()
}
for i := 0; i < n; i++ { require.NoError(t, <-errs) }
for i := 0; i < n; i++ { require.NotEmpty(t, <-results) }
```
- If each goroutine uses a unique value (like `amount`), send it alongside the result or use a struct channel.
- When asserting final balances, compute expected changes using `n * amount` and verify both accounts.

### Quick checklist for great tests
- Mock only the boundary (DB store) and test your business/app logic.
- Use `httptest` + table-driven tests for handlers.
- Always assert status codes and response bodies.
- Map `sql.ErrNoRows` → 404, unexpected errors → 500.
- For concurrency: buffer channels, read exactly `n` items, avoid `len(ch)` assertions.
- Keep handlers pure: pass `ctx.Request.Context()` to store methods.

### Makefile helpers (recap)
```makefile
# Run all tests
make test
# One test
make test-one t=TestName
# Start DB + migrate + test
make runtest
```

With these patterns, anyone can quickly generate mocks, write meaningful handler and store tests, and scale confidently with safe transactions and solid API contracts.

### Gin Test Mode
To reduce noisy logs during tests, set Gin to test mode. It disables logging and trims output.

- Global (recommended) in a package `TestMain`:
```go
// api/main_test.go
package api

import (
  "os"
  "testing"
  "github.com/gin-gonic/gin"
)

func TestMain(m *testing.M) {
  gin.SetMode(gin.TestMode)
  os.Exit(m.Run())
}
```

- Or set it at the start of a specific test:
```go
gin.SetMode(gin.TestMode)
server := NewServer(mockStore)
// proceed with httptest...
```
